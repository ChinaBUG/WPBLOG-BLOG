---
ID: 278
post_title: 常用正则表达式
author: ChinaBUG
post_excerpt: 常用正则表达式,收集...
layout: post
permalink: >
  http://blog.ipodmp.com/2009/12/common-regular-expressions.html
published: true
post_date: 2009-12-10 17:00:15
---
"^\d+$"　　//非负整数（正整数 + 0）
"^[0-9]*[1-9][0-9]*$"　　//正整数
"^((-\d+)|(0+))$"　　//非正整数（负整数 + 0）
"^-[0-9]*[1-9][0-9]*$"　　//负整数
"^-?\d+$"　　　　//整数
"^\d+(\.\d+)?$"　　//非负浮点数（正浮点数 + 0）
"^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$"　　//正浮点数
"^((-\d+(\.\d+)?)|(0+(\.0+)?))$"　　//非正浮点数（负浮点数 + 0）
"^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$"　　//负浮点数
"^(-?\d+)(\.\d+)?$"　　//浮点数
"^[A-Za-z]+$"　　//由26个英文字母组成的字符串
"^[A-Z]+$"　　//由26个英文字母的大写组成的字符串
"^[a-z]+$"　　//由26个英文字母的小写组成的字符串
"^[A-Za-z0-9]+$"　　//由数字和26个英文字母组成的字符串
"^\w+$"　　//由数字、26个英文字母或者下划线组成的字符串
"^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$"　　　　//email地址
"^[a-zA-z]+://(\w+(-\w+)*)(\.(\w+(-\w+)*))*(\?\S*)?$"　　//url
/^(d{2}|d{4})-((0([1-9]{1}))|(1[1|2]))-(([0-2]([1-9]{1}))|(3[0|1]))$/ // 年-月-日
/^((0([1-9]{1}))|(1[1|2]))/(([0-2]([1-9]{1}))|(3[0|1]))/(d{2}|d{4})$/ // 月/日/年
"^([w-.]+)@(([[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3}.)|(([w-]+.)+))([a-zA-Z]{2,4}|[0-9]{1,3})(]?)$" //Emil
"(d+-)?(d{4}-?d{7}|d{3}-?d{8}|^d{7,8})(-d+)?" //电话号码
"^(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5]).(d{1,2}|1dd|2[0-4]d|25[0-5])$" //IP地址

&nbsp;

匹配中文字符的正则表达式： [\u4e00-\u9fa5]
匹配双字节字符(包括汉字在内)：[^\x00-\xff]
匹配空行的正则表达式：\n[\s| ]*\r
匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/&gt;/
匹配首尾空格的正则表达式：(^\s*)|(\s*$)
匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
匹配网址URL的正则表达式：^[a-zA-z]+://(<a href="file://w+(-//w+)*)(//.(//w+(-//w+)*))*(//?//S*)?$">\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$</a>
匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
匹配国内电话号码：(\(\d{3,4}\)|\d{3,4}-|\s)?\d{8}
正确格式为：“XXXX-XXXXXXX”，“XXXX-XXXXXXXX”，“XXX-XXXXXXX”，

“XXX-XXXXXXXX”，“XXXXXXX”，“XXXXXXXX”。
验证身份证号（15位或18位数字）：“^d{15}|d{}18$”
匹配腾讯QQ号：^[1-9]*[1-9][0-9]*$
匹配中文字符的正则表达式： [u4e00-u9fa5]

匹配双字节字符(包括汉字在内)：[^x00-xff]

应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）

String.prototype.len=function(){return this.replace([^x00-xff]/g,"aa").length;}

匹配空行的正则表达式：n[s| ]*r

匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*&lt;/1&gt;|&lt;(.*) /&gt;/

匹配首尾空格的正则表达式：(^s*)|(s*$)

应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下：

String.prototype.trim = function()
{
return this.replace(/(^s*)|(s*$)/g, "");
}

利用正则表达式分解和转换IP地址：

下面是利用正则表达式匹配IP地址，并将IP地址转换成对应数值的Javascript程序：

function IP2V(ip)
{
re=/(d+).(d+).(d+).(d+)/g //匹配IP地址的正则表达式
if(re.test(ip))
{
return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1
}
else
{
throw new Error("Not a valid IP address!")
}
}

不过上面的程序如果不用正则表达式，而直接用split函数来分解可能更简单，程序如下：

var ip="10.100.20.168"
ip=ip.split(".")
alert("IP值是："+(ip[0]*255*255*255+ip[1]*255*255+ip[2]*255+ip[3]*1))

匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*

匹配网址URL的正则表达式：<a href="http://([w-]+.)+[w-]+(/[w">http://([w-]+.)+[w-]+(/[w</a>- ./?%&amp;=]*)?

利用正则表达式去除字串中重复的字符的算法程序：

var s="abacabefgeeii"
var s1=s.replace(/(.).*1/g,"$1")
var re=new RegExp("["+s1+"]","g")
var s2=s.replace(re,"")
alert(s1+s2) //结果为：abcefgi

得用正则表达式从URL地址中提取文件名的javascript程序，如下结果为page1

s="<a href="http://www.9499.net/page1.htm">http://www.ipodmp/page1.htm</a>"
s=s.replace(/(.*/){0,}([^.]+).*/ig,"$2")
alert(s)

利用正则表达式限制网页表单里的文本框输入内容：

用正则表达式限制只能输入中文：onkeyup="value=value.replace(/[^u4E00-u9FA5]/g,'')" onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^u4E00-u9FA5]/g,''))"

用正则表达式限制只能输入全角字符： onkeyup="value=value.replace(/[^uFF00-uFFFF]/g,'')" onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^uFF00-uFFFF]/g,''))"

用正则表达式限制只能输入数字：onkeyup="value=value.replace(/[^d]/g,'') "onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^d]/g,''))"

用正则表达式限制只能输入数字和英文：onkeyup="value=value.replace(/[W]/g,'') "onbeforepaste="clipboardData.setData('text',clipboardData.getData('text').replace(/[^d]/g,''))"

==============================================

正则表达式的解释说明
表达式意义：

1.字符

x    字符 x。例如a表示字符a
\\    反斜线字符。在书写时要写为<a>\\\\</a>。（注意：因为java在第一次解析时,把<a>\\\\</a>解析成正则表达式\\，在第二次解析时再解析为\，所以凡是不是1.1列举到的转义字符，包括1.1的\\,而又带有\的都要写两次）
\0n    带有八进制值 0的字符 n (0 &lt;= n &lt;= 7)
\0nn    带有八进制值 0的字符 nn (0 &lt;= n &lt;= 7)
\0mnn    带有八进制值 0的字符 mnn（0 &lt;= m &lt;= 3、0 &lt;= n &lt;= 7）
\xhh    带有十六进制值 0x的字符 hh
\uhhhh    带有十六进制值 0x的字符 hhhh
\t    制表符 ('\u0009')
\n    新行（换行）符 ('\u000A')
\r    回车符 ('\u000D')
\f    换页符 ('\u000C')
\a    报警 (bell) 符 ('\u0007')
\e    转义符 ('\u001B')
\cx    对应于 x 的控制符
2.字符类
[abc]    a、b或 c（简单类）。例如[egd]表示包含有字符e、g或d。
[^abc]    任何字符，除了 a、b或 c（否定）。例如[^egd]表示不包含字符e、g或d。
[a-zA-Z]    a到 z或 A到 Z，两头的字母包括在内（范围）
[a-d[m-p]]    a到 d或 m到 p：[a-dm-p]（并集）
[a-z&amp;&amp;[def]]    d、e或 f（交集）
[a-z&amp;&amp;[^bc]]    a到 z，除了 b和 c：[ad-z]（减去）
[a-z&amp;&amp;[^m-p]]    a到 z，而非 m到 p：[a-lq-z]（减去）
3.预定义字符类(注意反斜杠要写两次，例如\d写为<a href="file://\\d">\\d</a>)任何字符

（与行结束符可能匹配也可能不匹配）
\d    数字：[0-9]
\D    非数字： [^0-9]
\s    空白字符：[ \t\n\x0B\f\r]
\S    非空白字符：[^\s]
\w    单词字符：[a-zA-Z_0-9]
\W    非单词字符：[^\w]
4.POSIX 字符类（仅 US-ASCII)(注意反斜杠要写两次，例如\p{Lower}写为<a href="file://\\p{Lower">\\p{Lower</a>})
\p{Lower}    小写字母字符：[a-z]。
\p{Upper}    大写字母字符：[A-Z]
\p{ASCII}    所有 ASCII：[\x00-\x7F]
\p{Alpha}    字母字符：[\p{Lower}\p{Upper}]
\p{Digit}    十进制数字：[0-9]
\p{Alnum}    字母数字字符：[\p{Alpha}\p{Digit}]
\p{Punct}    标点符号：!"#$%&amp;'()*+,-./:;&lt;=&gt;?@[\]^_`{|}~
\p{Graph}    可见字符：[\p{Alnum}\p{Punct}]
\p{Print}    可打印字符：[\p{Graph}\x20]
\p{Blank}    空格或制表符：[ \t]
\p{Cntrl}    控制字符：[\x00-\x1F\x7F]
\p{XDigit}    十六进制数字：[0-9a-fA-F]
\p{Space}    空白字符：[ \t\n\x0B\f\r]
5.java.lang.Character 类（简单的 java 字符类型）
\p{javaLowerCase}    等效于 java.lang.Character.isLowerCase()
\p{javaUpperCase}    等效于 java.lang.Character.isUpperCase()
\p{javaWhitespace}    等效于 java.lang.Character.isWhitespace()
\p{javaMirrored}    等效于 java.lang.Character.isMirrored()
6.Unicode 块和类别的类
\p{InGreek}    Greek 块（简单块）中的字符
\p{Lu}    大写字母（简单类别）
\p{Sc}    货币符号
\P{InGreek}    所有字符，Greek 块中的除外（否定）
[\p{L}&amp;&amp;[^\p{Lu}]]     所有字母，大写字母除外（减去）
7.边界匹配器
^    行的开头，请在正则表达式的开始处使用^。例如：^(abc)表示以abc开头的字符串。注意编译的时候要设置参数MULTILINE，如 Pattern p = Pattern.compile(regex,Pattern.MULTILINE);
$    行的结尾，请在正则表达式的结束处使用。例如：(^bca).*(abc$)表示以bca开头以abc结尾的行。
\b    单词边界。例如\b(abc)表示单词的开始或结束包含有abc,（abcjj、jjabc 都可以匹配）
\B    非单词边界。例如\B(abc)表示单词的中间包含有abc,(jjabcjj匹配而jjabc、abcjj不匹配)
\A    输入的开头
\G    上一个匹配的结尾(个人感觉这个参数没什么用)。例如<a href="file://\\Gdog">\\Gdog</a>表示在上一个匹配结尾处查找dog如果没有的话则从开头查找,注意如果开头不是dog则不能匹配。
\Z    输入的结尾，仅用于最后的结束符（如果有的话）
行结束符 是一个或两个字符的序列，标记输入字符序列的行结尾。
以下代码被识别为行结束符：
‐新行（换行）符 ('\n')、
‐后面紧跟新行符的回车符 ("\r\n")、
‐单独的回车符 ('\r')、
‐下一行字符 ('\u0085')、
‐行分隔符 ('\u2028') 或
‐段落分隔符 ('\u2029)。
\z    输入的结尾
当编译模式时，可以设置一个或多个标志，例如
Pattern pattern = Pattern.compile(patternString,Pattern.CASE_INSENSITIVE + Pattern.UNICODE_CASE);
下面六个标志都是支持的：
‐CASE_INSENSITIVE：匹配字符时与大小写无关，该标志默认只考虑US ASCII字符。
‐UNICODE_CASE：当与CASE_INSENSITIVE结合时，使用Unicode字母匹配
‐MULTILINE：^和$匹配一行的开始和结尾，而不是整个输入
‐UNIX_LINES： 当在多行模式下匹配^和$时，只将'\n'看作行终止符
‐DOTALL: 当使用此标志时，.符号匹配包括行终止符在内的所有字符
‐CANON_EQ: 考虑Unicode字符的规范等价
8.Greedy 数量词
X?    X，一次或一次也没有
X*    X，零次或多次
X+    X，一次或多次
X{n}    X，恰好 n 次
X{n,}    X，至少 n 次
X{n,m}    X，至少 n 次，但是不超过 m 次
9.Reluctant 数量词
X??    X，一次或一次也没有
X*?    X，零次或多次
X+?    X，一次或多次
X{n}?    X，恰好 n 次
X{n,}?    X，至少 n 次
X{n,m}?    X，至少 n 次，但是不超过 m 次
10.Possessive 数量词
X?+    X，一次或一次也没有
X*+    X，零次或多次
X++    X，一次或多次
X{n}+    X，恰好 n 次
X{n,}+    X，至少 n 次
X{n,m}+    X，至少 n 次，但是不超过 m 次
Greedy，Reluctant，Possessive的区别在于:(注意仅限于进行.等模糊处理时)
greedy量词被看作“贪婪的”，因为它第一次就读入整个被模糊匹配的字符串。如果第一个匹配尝试（整个输入字符串）失败，匹配器就会在被匹配字符串中的最后一位后退一个字符并且再次尝试，重复这个过程，直到找到匹配或者没有更多剩下的字符可以后退为止。根据表达式中使用的量词，它最后试图匹配的内容是1 个或者0个字符。
但是，reluctant量词采取相反的方式：它们从被匹配字符串的开头开始，然后逐步地一次读取一个字符搜索匹配。它们最后试图匹配的内容是整个输入字符串。
最后，possessive量词总是读完整个输入字符串，尝试一次（而且只有一次）匹配。和greedy量词不同，possessive从不后退。
11.Logical 运算符
XY    X 后跟 Y
X|Y    X 或 Y
(X)    X，作为捕获组。例如(abc)表示把abc作为一个整体进行捕获
12.Back 引用
\n    任何匹配的 nth捕获组
捕获组可以通过从左到右计算其开括号来编号。例如，在表达式 ((A)(B(C)))中，存在四个这样的组：
1        ((A)(B(C)))
2        \A
3        (B(C))
4        (C)
在表达式中可以通过\n来对相应的组进行引用，例如(ab)34\1就表示ab34ab，(ab)34(cd)\1\2就表示ab34cdabcd。
13.引用
\    Nothing，但是引用以下字符
\Q    Nothing，但是引用所有字符，直到 \E。QE之间的字符串会原封不动的使用(1.1中转义字符的除外)。例如, ab\\Q{|}\\\\E
可以匹配ab{|}\\
\E    Nothing，但是结束从 \Q开始的引用
14.特殊构造（非捕获）
(?:X)    X，作为非捕获组
(?idmsux-idmsux)     Nothing，但是将匹配标志由 on 转为 off。比如：表达式 (?i)abc(?-i)def 这时，(?i) 打开不区分大小写开关，abc 匹配
idmsux说明如下：
‐i CASE_INSENSITIVE :US-ASCII 字符集不区分大小写。(?i)
‐d UNIX_LINES : 打开UNIX换行符
‐m MULTILINE :多行模式(?m)
UNIX下换行为\n
WINDOWS下换行为\r\n(?s)
‐u UNICODE_CASE : Unicode 不区分大小写。(?u)
‐x COMMENTS :可以在pattern里面使用注解，忽略pattern里面的whitespace，以及"#"一直到结尾（#后面为注解）。(?x)例如(?x)abc#asfsdadsa可以匹配字符串abc
(?idmsux-idmsux:X)     X，作为带有给定标志 on - off 的非捕获组。与上面的类似，上面的表达式，可以改写成为：(?i:abc)def，或者 (?i)abc(?-i:def)
(?=X)    X，通过零宽度的正 lookahead。零宽度正先行断言，仅当子表达式 X 在 此位置的右侧匹配时才继续匹配。例如，\w+(?=\d) 表示字母后面跟数字，但不捕获数字（不回溯）
(?!X)    X，通过零宽度的负 lookahead。零宽度负先行断言。仅当子表达式 X 不在 此位置的右侧匹配时才继续匹配。例如，\w+(?!\d) 表示字母后面不跟数字，且不捕获数字。
(?&lt;=X)    X，通过零宽度的正 lookbehind。零宽度正后发断言。仅当子表达式 X 在 此位置的左侧匹配时才继续匹配。例如，(?&lt;=19)99 表示99前面是数字19，但不捕获前面的19。（不回溯）
(? (?&gt;X)    X，作为独立的非捕获组（不回溯）
(?=X)与(?&gt;X)的区别在于(?&gt;X)是不回溯的。例如被匹配的字符串为abcm
当表达式为a(?:b|bc)m是可以匹配的，而当表达式是a(?&gt;b|bc)时是不能匹配的，因为当后者匹配到b时，由于已经匹配，就跳出了非捕获组，而不再次对组内的字符进行匹配。可以加快速度。

=============================================

正则表达式语法
正则表达式是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”）。模式描述在搜索文本时要匹配的一个或多个字符串。

正则表达式示例

表达式  匹配
/^\s*$/
匹配空行。

/\d{2}-\d{5}/
验证由两位数字、一个连字符再加 5 位数字组成的 ID 号。

/&lt;\s*(\S+)(\s[^&gt;]*)?&gt;[\s\S]*&lt;\s*\/\1\s*&gt;/
匹配 HTML 标记。
下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为：
字符  说明
\
将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，“n”匹配字符“n”。“\n”匹配换行符。序列“\\”匹配“\”，“\(”匹配“(”。

^
匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与“\n”或“\r”之后的位置匹配。

$
匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与“\n”或“\r”之前的位置匹配。

*
零次或多次匹配前面的字符或子表达式。例如，zo* 匹配“z”和“zoo”。* 等效于 {0,}。

+
一次或多次匹配前面的字符或子表达式。例如，“zo+”与“zo”和“zoo”匹配，但与“z”不匹配。+ 等效于 {1,}。

?
零次或一次匹配前面的字符或子表达式。例如，“do(es)?”匹配“do”或“does”中的“do”。? 等效于 {0,1}。

{n}
n 是非负整数。正好匹配 n 次。例如，“o{2}”与“Bob”中的“o”不匹配，但与“food”中的两个“o”匹配。

{n,}
n 是非负整数。至少匹配 n 次。例如，“o{2,}”不匹配“Bob”中的“o”，而匹配“foooood”中的所有 o。“o{1,}”等效于“o+”。“o{0,}”等效于“o*”。

{n,m}
M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，“o{1,3}”匹配“fooooood”中的头三个 o。'o{0,1}' 等效于 'o?'。注意：您不能将空格插入逗号和数字之间。

?
当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是“非贪心的”。“非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的“贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串“oooo”中，“o+?”只匹配单个“o”，而“o+”匹配所有“o”。

.
匹配除“\n”之外的任何单个字符。若要匹配包括“\n”在内的任意字符，请使用诸如“[\s\S]”之类的模式。

(pattern)
匹配 pattern 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果“匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用“\(”或者“\)”。

(?:pattern)
匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用“or”字符 (|) 组合模式部件的情况很有用。例如，'industr(?:y|ies) 是比 'industry|industries' 更经济的表达式。

(?=pattern)
执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 pattern 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?=95|98|NT|2000)' 匹配“Windows 2000”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。

(?!pattern)
执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，'Windows (?!95|98|NT|2000)' 匹配“Windows 3.1”中的 “Windows”，但不匹配“Windows 2000”中的“Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。

x|y
匹配 x 或 y。例如，'z|food' 匹配“z”或“food”。'(z|f)ood' 匹配“zood”或“food”。

[xyz]
字符集。匹配包含的任一字符。例如，“[abc]”匹配“plain”中的“a”。

[^xyz]
反向字符集。匹配未包含的任何字符。例如，“[^abc]”匹配“plain”中的“p”。

[a-z]
字符范围。匹配指定范围内的任何字符。例如，“[a-z]”匹配“a”到“z”范围内的任何小写字母。

[^a-z]
反向范围字符。匹配不在指定的范围内的任何字符。例如，“[^a-z]”匹配任何不在“a”到“z”范围内的任何字符。

\b
匹配一个字边界，即字与空格间的位置。例如，“er\b”匹配“never”中的“er”，但不匹配“verb”中的“er”。

\B
非字边界匹配。“er\B”匹配“verb”中的“er”，但不匹配“never”中的“er”。

\cx
匹配 x 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。x 的值必须在 A-Z 或 a-z 之间。如果不是这样，则假定 c 就是“c”字符本身。

\d
数字字符匹配。等效于 [0-9]。

\D
非数字字符匹配。等效于 [^0-9]。

\f
换页符匹配。等效于 \x0c 和 \cL。

\n
换行符匹配。等效于 \x0a 和 \cJ。

\r
匹配一个回车符。等效于 \x0d 和 \cM。

\s
匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。

\S
匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。

\t
制表符匹配。与 \x09 和 \cI 等效。

\v
垂直制表符匹配。与 \x0b 和 \cK 等效。

\w
匹配任何字类字符，包括下划线。与“[A-Za-z0-9_]”等效。

\W
与任何非单词字符匹配。与“[^A-Za-z0-9_]”等效。

\xn
匹配 n，此处的 n 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，“\x41”匹配“A”。“\x041”与“\x04”&amp;“1”等效。允许在正则表达式中使用 ASCII 代码。

\num
匹配 num，此处的 num 是一个正整数。到捕获匹配的反向引用。例如，“(.)\1”匹配两个连续的相同字符。

\n
标识一个八进制转义码或反向引用。如果 \n 前面至少有 n 个捕获子表达式，那么 n 是反向引用。否则，如果 n 是八进制数 (0-7)，那么 n 是八进制转义码。

\nm
标识一个八进制转义码或反向引用。如果 \nm 前面至少有 nm 个捕获子表达式，那么 nm 是反向引用。如果 \nm 前面至少有 n 个捕获，则 n 是反向引用，后面跟有字符 m。如果两种前面的情况都不存在，则 \nm 匹配八进制值 nm，其中 n 和 m 是八进制数字 (0-7)。

\nml
当 n 是八进制数 (0-3)，m 和 l 是八进制数 (0-7) 时，匹配八进制转义码 nml。

\un
匹配 n，其中 n 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (?)。