---
ID: 4053
post_title: 什么才算是真正的编程能力？
author: ChinaBUG
post_excerpt: ""
layout: post
permalink: >
  http://blog.ipodmp.com/2015/06/what-is-a-real-programming-skills.html
published: true
post_date: 2015-06-10 09:51:36
---
<em>虫神曰：</em>
<em>一大早看到51CTO推荐的本文，觉得非常不错的，特别是刘贺网友的答复。</em>
<em>虫子本人觉得，作为一个刚入编程行业的人，抄袭在所难免，这个是进步的阶梯，没什么大不了的，往往这个阶段代表着学习能力，而非编程能力。</em>
<em>过了初期就会出现变化，那就是自己动手开发一些轮子了，这个不一定是发明，而是创建，因为这个阶段的人基本上不懂得去找看看有没有同类的代码，当然，这个不是绝对的，但是起码在轮子跟轮子之间的结合的轮子肯定是需要自己写的，别告诉我你找到的代码都是能直接满足你的需求的，那是神，不是人了。所以，这个阶段是可以看出编程的能力的，最起码应该叫做“变现”能力。</em>
<em>再接着就是老油条的了，见识多了，所以手上有点常用代码，也知道一些常用类库，自然就是举手就来，这个时候基本上就是写中间的粘合代码，而不会去重复的创造了...但是，难免也会遇上搞不定的情况，这个时候就需要自己来动手写了。所以，这个阶段也是可以看出编程的能力，这个阶段是创造的时候。</em>
<em>后面的阶段发展就不多说了，总的要说一句，作为程序员，其实，真的没什么了不起的事情，别以为作为程序员就多伟大，多么的不可取代。真正了不起的人物还是那些有天分，开发工具，创造语言给我们用的那些少数人，其他的，仅仅体现在对工具的理解深度，熟练程度等方面的区别，绝对不是什么编程能力的区别。</em>
<em>之前还看过一篇文章讨论：《程序员需要不需要天份》差不多的意思的讨论，其实，对于大众的程序员来说，这个不需要天份，只要你肯下苦功夫，一定能做好程序员，但是你要进入那些少数的人群中，比如编译器方面的专家，这个不仅仅需要你下苦功夫，还需要那么一点的天份的，要是下苦功夫都能成事，那么天才名号有点不值钱噢。</em>
<em>个人经常去&lt;<a href="http://www.nowamagic.net/">简明现代魔法</a>&gt;，前段时间在网站的“大音声稀”中看到一句话：“<span style="text-decoration: underline;">我亦无他, 唯手熟尔</span>”，这句话令我觉得，这个人是一个谦虚的人，因为确实是如此，我也时常这么认为，不过现代魔法中是挺不错的一个网站，值得推荐。--当然不是做广告哈~另外，我之后查一下原来这句话是欧阳修《卖油翁》中的语句。</em>

~.~

<strong>问题：什么才算是真正的编程能力？</strong>

还 在读书，也在实验室帮忙做了些东西，自己也搭过几个网站。在周围人看来似乎好像我很厉害，做了那么多东西，但是我发现这些东西虽然是我做的，但是实际上我 手把手自己写的代码却并没有多少，很多都是用开源的东西，我写的代码无非是把别人的东西整合下，类似于胶水一样的工作。

<a href="http://s4.51cto.com/wyfs02/M00/6E/39/wKiom1V2lvCA3T-uAAD8XWTTb3w296.jpg" target="_blank"><img class="fit-image" src="http://s4.51cto.com/wyfs02/M00/6E/39/wKiom1V2lvCA3T-uAAD8XWTTb3w296.jpg" alt=" 什么才算是真正的编程能力？ " width="457" height="311" border="0" /></a>

我之前所认为的编程是全手动一行一行敲代码，但是现在我发现哪怕是工程上也有很多人是复制黏贴来解决问题的，并且提倡不要重复造轮子。

但是靠谷歌和复制别人的轮子，虽然我做出了很多东西，可是我并不觉得自己能力上有提升，倒是利用搜索引擎的能力的确提升了不少。而学校里另外一波搞ACM的人，他们每天刷题练算法，或许倒是的确提升了点编程能力，但是对工程几乎一窍不通。

所以我现在就很困惑，所谓的编程能力到底是什么，我该如何提升自己的编程能力？

<strong>回答者：刘贺，...</strong>

非常好的一个问题。这可能是我在知乎见到过的问编程有关的问题中问得最好的一个了。我非常喜欢这个问题。

计算机科学有两类根本问题。一类是理论：算法，数据结构，复杂度，机器学习，模式识别，等等等。一类是系统：操作系统，网络系统，分布式系统，存储系统，游戏引擎，等等等等。

理论走的是深度，是在追问在给定的计算能力约束下如何把一个问题解决得更快更好。而系统走的是广度，是在追问对于一个现实的需求如何在众多的技术中设计出最多快好省的技术组合。

搞ACM的人，只练第一类。像你这样的更偏向于第二类。其实挺难得的，但很可惜的是第二类能力没有简单高效的测量考察方法，不像算法和数据结构有ACM竞赛，所以很多系统的苗子都因为缺少激励和正确引导慢慢就消隐了。

所以比尔盖茨才会说，看到现在学编程的人经常都把编程看作解各种脑筋急转弯的问题，他觉得很遗憾。

做系统，确实不提倡“重复发明轮子”。但注意，是不提倡“重复发明”，不是不提倡“重新制造”。恰恰相反的，我以为，系统的编程能力正体现在“重新制造”的能力。

能 把已有的部件接起来，这很好。但当你恰好缺一种关键的胶水的时候，你能写出来吗？当一个已有的部件不完全符合你的需求的时候，你能改进它吗？如果你用的部 件中有bug，你能把它修好吗？在网上繁多的类似功能的部件中，谁好谁坏？为什么？差别本质吗？一个开源代码库，你能把它从一个语言翻译到另一个语言吗？ 从一个平台移植到另一个平台吗？能准确估计自己翻译和移植的过程需要多少时间吗？能准确估计翻译和移植之后性能是会有提升还是会有所下降吗？

系统编程能力体现在把已有的代码拿来并变成更好的代码，体现在把没用的代码拿来并变成有用的代码，体现在把一个做好的轮子拿来能画出来轮子的设计蓝图，并用道理解释出设计蓝图中哪些地方是关键的，哪些地方是次要的，哪些地方是不容触碰的，哪些地方是还可以改进的。

如果你一点不懂理论，还是应该学点的。对于系统性能的设计上，算法和数据结构就像在自己手头的钱一样，它们不是万能的，但不懂是万万不行的。

怎 么提高系统编程能力呢？土办法：多造轮子。就像学画画要画鸡蛋一样，不是这世界上没有人会画鸡蛋，但画鸡蛋能驯服手指，感受阴影线条和笔触。所以，自己多 写点东西吧。写个编译器？渲染器？操作系统？web服务器？web浏览器？部件都一个个换成自己手写的，然后和已有的现成部件比一比，看看谁的性能好，谁 的易用性好？好在哪儿？差在哪儿？为什么？

更 聪明一点的办法：多拆轮子。多研究别人的代码是怎么写的。然而这个实践起来经常很难。原因：大部分工业上用的轮子可能设计上的思想和技术是好的，都设计和 制造过程都很烂，里面乱成一团，让人乍一看毫无头绪，导致其对新手来说非常难拆。这种状况其实非常糟糕。所以，此办法一般只对比较简单的轮子好使，对于复 杂的轮子，请量力而行。

轮 子不好拆，其实是一个非常严重的问题。重复发明轮子固然是时间的浪费，但当轮子复杂而又不好拆的时候，尤其是原来造轮子的人已经不在场的时候，重新发明和 建造轮子往往会成为无奈之下最好的选择。这是为什么工业界在明知道重复发明/制造轮子非常不好的情况下还在不断重复发明/制造轮子的根本原因。

程序本质是逻辑演绎的形式化表达，记载的是人类对这个世界的数字化理解。不能拆的轮子就像那一篇篇丢了曲谱的宋词一样，能读，却不能唱。

鄙人不才，正在自己研究怎么设计建造一种既好用又好拆的轮子。您没那么幸运，恐怕是等不到鄙人的技术做出来并发扬光大了。在那之前，多造轮子，多拆好拆的小轮子，应该是提高编程能力最好的办法了。

以上。嗯。

（文章属个人观点，与本人工作雇主无关。）

<strong><strong>回答者：</strong>mu peng，less is more</strong>

懂得取舍。

在有限的时间内，几乎没有系统可以做到完美。要快，要安全，高并发，易扩展，效率高，容易读，高内聚，低耦合...

大到一个网站，小到几个class，工程师都要清楚，要取什么，舍什么，这并不是那么容易的事。我们都有自己的性格，有的求新，有的求稳，有的求快，但具体到一个项目时，知道如何取舍对这个项目最好，很重要。

学校里的作业，没人在意你是不是写在一个大的main()里面，能跑就行。但做项目的时候，太多的东西要考虑，有时候，宁可简单易读，也不用快那么一点点；有时候，要做太多看不到的工作，却丝毫马虎不得；有时候，写了不如不写，留白也是一个学问。

曾经接手个项目，里面几乎所有的class，每个都有interface，各种继承，各种实现，理由是灵活性高，易扩展。真的易扩展吗？

我不知道。没多久，客户的需求就改了，各种拎不清的继承实现都化为乌有，一大半要重写。

问题在哪里？

不是编程不好，而是取舍的不好。在那个阶段，为30%的需求，花200%的努力，追求设计的滴水不漏，却舍弃快速实现，取得反馈的时机，这就是失误。需求总会变，客户看到越早，修改越早，影响越小。

很聪明的人，也可能做出很难用的系统，不一定是编程不好，可能是不愿，或不屑于取舍。不同的阶段，不同的项目，要取舍的东西也不同。编程只是手段，目的是解决问题，能力高不高，要看问题解决的好不好。不在于使用了什么高端算法，或是复杂的框架。

懂得如何取舍并不容易，需要对问题的深刻理解，对技术的胸有成竹，和身后无数个踩过的坑。但重要的是有取舍的意识，主动思考取舍什么，这样学的才会快。

<strong><strong>回答者：</strong>李遥，A Programmer</strong>

既然说的是编程能力，那首先就先把学术相关的能力排除才能说的清楚

接下来是我对编程的定义：所谓编程，就是预先设计好方案来指挥行为可预测的系统来自动（与临时手动相对）达到的想要的结果。从广义上说，企业家对一个公司的运作方式进行设计，然后这个公司自动运行产生利润也是一种编程

<strong>那么编程能力体现在两点</strong>

1.对可预测系统的理解：理解越深，预测能力越强，自己的智慧才越好发挥。这就是为什么学习软件编程最快的方式之一是“造轮子”

2. 如何把自己的目标转化成指挥方案，这其实就是“做应用题”的能力，我们从小学就在练习这个能力。现实世界的应用题可不会告诉你用什么知识点去建模，也不会 透露全部必要条件，因此增强这个能力需要深刻理解现实世界的运作方式。在软件行业，这被称作“理解垂直行业的业务逻辑”

顺带说一下，所谓“Hacking”，其实就是在深刻理解一个系统的基础上，用最小的代价改变这个系统来达到自己的目的。“Hacking”之所以看起来出人意料，就是因为理解越深刻，需要的做的改动越少。如果理解不深刻，那就要从头造一个系统了，那就不聪明了

<strong>回答者：</strong><strong>丁盛豪，网络媒体HeckPsi.com创始人</strong>

谢 @花满楼 邀请。

对于编程能力这个问题其实我也想过很久，这个东西确实非常难界定。单纯靠算法水平、编程速度、工程经验都很难说是编程能力。

虽然这个东西的影响因素非常庞大，但从我日常的工作来看，其实我觉得衡量编程水平最靠谱的方法是观察这个程序员 Debug 的能力。

程 序从本质上来说就是 输入 -&gt; 处理 -&gt; 输出 的过程，而中间的处理就像是一个巨大的黑盒子。而这个黑盒子的本身就是程序，在大多数情况下你并不能看到这个黑盒子的全貌。从常识上写一个不存在 bug 的程序是一件 几乎 不可能完成的任务。即使是敲个最简单的 Hello World 程序，你也很难保证编译器不给你抽几下风。尤其是当这个程序变得非常庞大时，写程序这件事的本身就是 盲人摸象 的过程。程序员必须要有相当好的 全局观 ，才能保证自己的程序良好运行而不出问题，并能在出了问题之后能够做出迅速的定位和修复。

所以观察一个程序员能否 迅速Debug 的过程就是一个很好的判断依据。我举个例子来说，我几周前给手机刷了机，第二天早上准备去晨跑，发现手机 GPS 不工作。于是我立刻分析了出现问题可能的地方：

<strong>GPS 模块硬件 -&gt; GPS 驱动 -&gt; 系统配置 -&gt; GPS 权限 -&gt; 软件兼容性</strong>

由 于想起刚刷了机，基本可以排除硬件问题。而软件之前同样在其它 Android 5.1 机器上跑过，同时跑了下 Google Maps 也不能定位，排除兼容性问题。原生系统的权限系统非常简单，基本排除是权限。出问题的可能是第三方 ROM 的驱动有问题或者配置文件。观察到 A-GPS 基站辅助定位也不工作，基本排除 GPS 驱动问题。确认是配置文件有问题，检查 /etc/gps.conf 竟是空文件。于是就在手机上用文本编辑器顺手码了一段配置，重启后问题修复。

这就是一次非常流畅准确的对一个未知的 Bug 定位和修复的过程。

由 于 Bug 的未知性，可以很好避免一些你在判断时可能遇到的 作弊 情况，我们知道现在很多人为了面试无所不用其极。就算是以前非常经典的面试问题，现在也很不靠谱。现在你问 “如何理解面向对象编程？” 和你对答如流的人可能并不真正理解 OOP，不过背的很熟而已。以前觉得算法是个很好验证水平的切入点，自从 LeetCode 背题流的出现，这招现在也不怎么靠谱。而 Debug 是个无法 提前准备的东西，所以对于编程能力的校验通常很准确。

而 且，Debug 的过程中会接触到自己很多不熟悉的知识。由于编程本身就是一个 Engineering，正常的过程就是在 码字 -&gt; 出问题 -&gt; 学习 -&gt; 修改 的过程中循环。如果你对算法不熟悉，那么遇到程序性能问题的时候你硬着头皮也要用学习算法知识来解决掉。所以这是一项非常综合的能力，是程序员 知识、智力、经验 的综合体现。

<strong>至于如何提升编程能力？</strong>

多写、多错、多学。没有捷径，捷径只不过是作弊。作弊能帮你找到工作，但并不能真正解决问题。

<strong><strong><strong><strong>回答者：</strong></strong></strong>陈浩骏，call me Reid / 会写Java的猴子</strong>

<strong>MIT算法导论第一堂课:</strong>

每天都编程 x年后一定会变成专家 (忘了x多少 不是重点

轮子多造多模仿 能力自然提升

什么发展都是从量到质的 要相信

现在我也是搞系统编程 除了看source code和造轮

也是可以有空刷刷acm的

而且只有帮助没有坏处喔

系统编程一旦考虑到效能问题 离不开经典的一些算法的

显然大部分的我们都不会成为高手如温赵轮

但是成为编程好手 进个好公司 钱多赚些 生活舒服些 应该是普遍程序员的共同目标

不要想太多 拼命code就是了

共勉

如此。

<strong><strong><strong><strong><strong>回答者：</strong></strong></strong></strong>vczh，专业造轮子 </strong><strong>https://github.com/vczh-libraries</strong>

都不知道宣传不要重复造轮子的人是怀着什么险恶的用心，原话明明是不要重新发明轮子。

这是什么意思呢？就是说你要多看论文多看书，少抄代码。

<strong><strong><strong><strong><strong><strong>回答者：</strong></strong></strong></strong></strong></strong><strong>达达，服务端程序员</strong>

程序员就是把人类的需求语言翻译成计算机语言的人，所以可以通用译事三难：“信、达、雅”。

<strong><strong><strong><strong><strong><strong><strong>回答者：</strong></strong></strong></strong></strong></strong></strong><strong>Kim Leo</strong>

其实，搭网站，写MIS/CMS/ERP这些，就算是一行行的写代码，结果也只能是你的领域知识不断提升，对于“编程能力”的提升没有多少的。就像是你根本无法解释在你写的系统中哪个地方应用了动态规划一样。

所以相对来说你所需要的是一些计算机科学内的领域知识。

还有，假如你写了代码要给别人看和给其他程序员用，应该就开始慢慢考虑接口和设计了。

或者你需要的是一本分析模式？

<strong><strong><strong><strong><strong><strong><strong><strong>回答者：</strong></strong></strong></strong></strong></strong></strong></strong><strong>JX Consp</strong>

看看别人的轮子的形貌（主要是接口，其次是效率）之后自己造一个轮子

其实 STL 源码剖析 和 modern c++ design 不错，唯一问题是选择了 c++ 做教学语言

有兴趣可以学点认知和设计来了解好的接口长得是怎样的

<strong><strong><strong><strong><strong><strong><strong><strong><strong>回答者：</strong></strong></strong></strong></strong></strong></strong></strong></strong><strong>海涛，软件开发需要低成本、快速响应</strong>

<strong>第1层：</strong>能做成东西（能运行）

<strong>第2层：</strong>做的东西能长时间或高负荷地运行

<strong>第3层：</strong>做的东西能长时间在高负荷下运行

<strong>第4层：</strong>能预先知道什么才是客户/行业需要的功能，并以最符合的代价（金钱、硬件、期限、人力）实现

<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>回答者：</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><strong>DreamPiggy</strong>

多看书

多思考

改别人代码

学别人的架构

做自己的软件

写自己的架构

或许如此循环就入坑了吧。